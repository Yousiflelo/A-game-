<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ - Ø¥ØµÙ„Ø§Ø­ Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Cairo', sans-serif;
            background-color: #0d1117;
            color: #e6edf3;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        #instructions {
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 150, 255, 0.3);
            max-width: 90%;
            margin: 20px;
            border: 1px solid rgba(0, 150, 255, 0.2);
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 20px rgba(0, 150, 255, 0.3); }
            to { box-shadow: 0 0 40px rgba(0, 150, 255, 0.6); }
        }
        #message-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 101;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transform: translateY(-10px);
        }

        /* ØªØ­Ø³ÙŠÙ† Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ */
        #mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 50;
        }
        
        #joystick-area {
            position: absolute;
            bottom: 25px;
            left: 25px;
            width: 160px;
            height: 160px;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 70%);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        #joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(0,150,255,0.9) 0%, rgba(0,100,200,0.9) 100%);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.9);
            box-shadow: 0 4px 15px rgba(0,150,255,0.4);
            transition: transform 0.1s;
        }

        #jump-button {
            position: absolute;
            bottom: 35px;
            right: 35px;
            width: 110px;
            height: 110px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.1) 70%);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.6rem;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 150, 255, 0.4);
            transition: all 0.1s;
            border: 2px solid rgba(255,255,255,0.3);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        #jump-button:active {
            background: radial-gradient(circle, rgba(0,150,255,0.6) 0%, rgba(0,100,200,0.6) 100%);
            transform: scale(0.95);
        }
        
        #look-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            touch-action: none;
        }

        /* Ù…Ø¤Ø´Ø± Ø§Ù„Ø·Ø§Ù‚Ø© */
        #energy-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.2);
        }
        #energy-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ff00 0%, #ffff00 50%, #ff0000 100%);
            transition: width 0.3s;
            border-radius: 8px;
        }

        /* Ù…Ø¤Ø´Ø± Ø§Ù„ØªØµØ§Ø¯Ù… */
        #collision-debug {
            position: absolute;
            bottom: 20px;
            right: 160px;
            background: rgba(255, 50, 50, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            display: none;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }
            #instructions .desktop-keys {
                display: none;
            }
            #energy-bar {
                width: 150px;
                height: 15px;
            }
            #collision-debug {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="message-box"></div>
    <div id="energy-bar">
        <div id="energy-fill"></div>
    </div>
    <div id="collision-debug">ØªØµØ§Ø¯Ù…: 0</div>
    <div id="overlay">
        <div id="instructions" class="space-y-4">
            <h1 class="text-4xl font-bold bg-gradient-to-r from-cyan-400 to-blue-500 bg-clip-text text-transparent">
                Ù…Ø¯ÙŠÙ†Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ - Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª
            </h1>
            <p class="text-lg text-gray-300">ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ÙƒÙ„Ø© Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø±Ø¶ÙŠØ© ÙˆØ§Ù„Ù…Ø¨Ø§Ù†ÙŠ</p>

            <div class="bg-yellow-900/30 border border-yellow-700 p-4 rounded-xl mt-4">
                <h2 class="text-xl font-semibold text-yellow-300 mb-2">âš ï¸ Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ©:</h2>
                <ul class="text-sm text-yellow-200 text-right space-y-1">
                    <li>âœ… Ù†Ø¸Ø§Ù… ØªØµØ§Ø¯Ù… Ù…Ø­Ø³Ù‘Ù† Ù„Ù…Ù†Ø¹ Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚</li>
                    <li>âœ… Ø§ÙƒØªØ´Ø§Ù ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ø³Ø§Ù…</li>
                    <li>âœ… Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø³Ù‚ÙˆØ· ØªØ­Øª Ø§Ù„Ø£Ø±Ø¶</li>
                    <li>âœ… ØªÙ‚Ù„ÙŠÙ„ Ø§Ø­ØªÙƒØ§Ùƒ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©</li>
                </ul>
            </div>

            <button id="startButton" class="mt-8 px-10 py-4 bg-gradient-to-r from-blue-600 to-cyan-500 hover:from-blue-700 hover:to-cyan-600 text-white font-bold rounded-xl transition-all duration-300 shadow-2xl hover:shadow-cyan-500/25 hover:scale-105 active:scale-95">
                ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø­Ù„Ø©
            </button>
        </div>
    </div>
    
    <!-- Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ -->
    <div id="mobile-controls">
        <div id="look-area"></div>
        <div id="joystick-area">
            <div id="joystick-thumb"></div>
        </div>
        <div id="jump-button">âš¡</div>
    </div>

    <script type="module">
        // Ø§Ù„Ø«ÙˆØ§Ø¨Øª ÙˆØ§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
        const CITY_SIZE = 400;
        const MAX_BUILDINGS = 50; // ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ Ù„Ù„Ø£Ø¯Ø§Ø¡
        const BASE_JUMP_VELOCITY = 16;
        const MAX_JUMPS = 3;
        const JOYSTICK_RADIUS = 75;

        let camera, scene, renderer;
        let world, playerBody, enemyBody, groundBody;
        let groundMesh, enemyMesh, playerMesh;
        let isAuthReady = false;
        let jumpsRemaining = MAX_JUMPS;
        let lastJumpTime = 0;
        let energy = 100;
        let collisionCount = 0;

        // Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ø³Ø§Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
        let physicsBodies = [];

        // Ø­Ø§Ù„Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù„Ø§Ø¹Ø¨
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;
        const maxSpeed = 15;
        let lastTime;

        // Ø­Ø§Ù„Ø© Ø¹ØµØ§ Ø§Ù„ØªØ­ÙƒÙ…
        let joystickCenter = { x: 0, y: 0 };
        let activeTouchId = null;
        let isMobile = window.innerWidth <= 768;

        // Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        let controls = { pitch: -0.3, yaw: 0 };

        // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
        function showMessage(text) {
            const box = document.getElementById('message-box');
            box.textContent = text;
            box.style.opacity = 1;
            box.style.transform = 'translateY(0)';
            
            setTimeout(() => {
                box.style.opacity = 0;
                box.style.transform = 'translateY(-10px)';
            }, 3000);
        }

        // ØªØ­Ø¯ÙŠØ« Ø·Ø§Ù‚Ø© Ø§Ù„Ù‚ÙØ²
        function updateEnergyBar() {
            const fill = document.getElementById('energy-fill');
            fill.style.width = `${energy}%`;
        }

        // ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„ØªØµØ§Ø¯Ù…
        function updateCollisionDebug() {
            const debug = document.getElementById('collision-debug');
            debug.textContent = `ØªØµØ§Ø¯Ù…: ${collisionCount}`;
        }

        // 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„ÙÙŠØ²ÙŠØ§Ø¡
        function init() {
            // Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87a6d6);
            scene.fog = new THREE.FogExp2(0x87a6d6, 0.0015);

            // Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 10, 20);

            // Ø§Ù„Ù…Ø¶ÙŠÙ Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø¬ÙˆØ¯Ø©
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // Ø¹Ø§Ù„Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø­Ø³Ù†Ø©
            world = new CANNON.World();
            world.gravity.set(0, -25, 0); // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ© Ù‚Ù„ÙŠÙ„Ø§Ù‹
            world.broadphase = new CANNON.SAPBroadphase(); // ØªØ­Ø³ÙŠÙ† Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªØµØ§Ø¯Ù…
            world.solver.iterations = 20; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª Ù„Ø¯Ù‚Ø© Ø£ÙƒØ«Ø±
            world.solver.tolerance = 0.001; // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ³Ø§Ù…Ø­
            
            // ØªØ­Ø³ÙŠÙ† Ù…ÙˆØ§Ø¯ Ø§Ù„ØªÙ„Ø§Ù…Ø³
            const groundMaterial = new CANNON.Material("ground");
            const playerMaterial = new CANNON.Material("player");
            const wallMaterial = new CANNON.Material("wall");
            
            // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…ÙˆØ§Ø¯
            groundMaterial.friction = 0.5;
            groundMaterial.restitution = 0.1;
            
            playerMaterial.friction = 0.2;
            playerMaterial.restitution = 0.3;
            
            wallMaterial.friction = 0.8;
            wallMaterial.restitution = 0.05;
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ù…ÙˆØ§Ø¯
            const groundPlayerContact = new CANNON.ContactMaterial(
                groundMaterial,
                playerMaterial,
                {
                    friction: 0.5,
                    restitution: 0.1,
                    contactEquationStiffness: 1e8,
                    contactEquationRelaxation: 3
                }
            );
            
            const groundWallContact = new CANNON.ContactMaterial(
                groundMaterial,
                wallMaterial,
                {
                    friction: 0.7,
                    restitution: 0.05,
                    contactEquationStiffness: 1e8,
                    contactEquationRelaxation: 3
                }
            );
            
            world.addContactMaterial(groundPlayerContact);
            world.addContactMaterial(groundWallContact);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©
            createRealisticEnvironment();
            createPlayer();
            createEnemy();

            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø³ØªÙ…Ø¹ÙŠÙ† Ù„Ù„ØªØ­ÙƒÙ…
            setupControls();

            // Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
            window.addEventListener('resize', onWindowResize);

            isAuthReady = true;
            updateEnergyBar();
            
            // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©
            showMessage("ğŸŒ Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ø¬Ø§Ù‡Ø²Ø© - Ù„Ù† ØªØ®ØªØ±Ù‚Ù‡Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø¢Ù†!");
        }

        // 2. Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ¦Ø© ÙˆØ§Ù‚Ø¹ÙŠØ©
        function createRealisticEnvironment() {
            // ===== Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© =====
            const groundGeometry = new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE, 100, 100);
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a7c59,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            groundMesh.position.y = 0;
            
            scene.add(groundMesh);

            // ===== Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ© Ù…Ø¹ Ù…Ø§Ø¯Ø© Ù…Ø­Ø³Ù†Ø© =====
            const groundShape = new CANNON.Plane();
            groundBody = new CANNON.Body({ 
                mass: 0,
                material: new CANNON.Material({
                    friction: 0.5,
                    restitution: 0.1
                })
            });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            groundBody.position.y = 0;
            world.addBody(groundBody);
            physicsBodies.push(groundBody);

            // ===== Ø´Ø¨ÙƒØ© Ø§Ù„Ø·Ø±Ù‚ =====
            createRoadNetwork();

            // ===== Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ© =====
            createRealisticBuildings();

            // ===== Ø¥Ø¶Ø§ÙØ© Ù†Ø¨Ø§ØªØ§Øª =====
            createVegetation();

            // ===== Ø¥Ø¶Ø§ÙØ© Ø³ÙŠØ§Ø±Ø§Øª =====
            createVehicles();

            // ===== Ø¥Ø¶Ø§Ø¡Ø© ÙˆØ§Ù‚Ø¹ÙŠØ© =====
            setupRealisticLighting();

            // ===== Ø¥Ø¶Ø§ÙØ© Ø­ÙˆØ§Ù Ù„Ù„Ù…Ø¯ÙŠÙ†Ø© =====
            createCityWalls();
        }

        // 3. Ø¥Ù†Ø´Ø§Ø¡ Ø­ÙˆØ§Ù Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
        function createCityWalls() {
            const wallHeight = 50;
            const wallThickness = 5;
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.3
            });

            // Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† Ø§Ù„Ø£Ø±Ø¨Ø¹Ø©
            const positions = [
                [CITY_SIZE/2 + wallThickness/2, wallHeight/2, 0],
                [-CITY_SIZE/2 - wallThickness/2, wallHeight/2, 0],
                [0, wallHeight/2, CITY_SIZE/2 + wallThickness/2],
                [0, wallHeight/2, -CITY_SIZE/2 - wallThickness/2]
            ];

            const dimensions = [
                [wallThickness, wallHeight, CITY_SIZE],
                [CITY_SIZE, wallHeight, wallThickness]
            ];

            positions.forEach((pos, index) => {
                const dimIndex = index < 2 ? 0 : 1;
                const wallGeometry = new THREE.BoxGeometry(...dimensions[dimIndex]);
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.position.set(...pos);
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;
                scene.add(wallMesh);

                // Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ Ù„Ù„Ø­Ø§Ø¦Ø·
                const wallShape = new CANNON.Box(new CANNON.Vec3(
                    dimensions[dimIndex][0]/2,
                    dimensions[dimIndex][1]/2,
                    dimensions[dimIndex][2]/2
                ));
                const wallBody = new CANNON.Body({ 
                    mass: 0,
                    material: new CANNON.Material({
                        friction: 0.8,
                        restitution: 0.05
                    })
                });
                wallBody.addShape(wallShape);
                wallBody.position.set(...pos);
                world.addBody(wallBody);
                physicsBodies.push(wallBody);
            });
        }

        // 4. Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø·Ø±Ù‚
        function createRoadNetwork() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.1
            });

            // Ø§Ù„Ø·Ø±Ù‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            for (let i = -CITY_SIZE/2; i <= CITY_SIZE/2; i += 50) {
                // Ø·Ø±Ù‚ Ø´Ù…Ø§Ù„-Ø¬Ù†ÙˆØ¨
                const roadGeometry = new THREE.PlaneGeometry(CITY_SIZE, 10);
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.set(i, 0.1, 0);
                road.receiveShadow = true;
                scene.add(road);

                // Ø·Ø±Ù‚ Ø´Ø±Ù‚-ØºØ±Ø¨
                if (i !== -CITY_SIZE/2) {
                    const crossRoad = new THREE.Mesh(roadGeometry, roadMaterial);
                    crossRoad.rotation.x = -Math.PI / 2;
                    crossRoad.rotation.z = Math.PI / 2;
                    crossRoad.position.set(0, 0.1, i);
                    crossRoad.receiveShadow = true;
                    scene.add(crossRoad);
                }
            }

            // Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø·Ø±ÙŠÙ‚
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            for (let i = -CITY_SIZE/2 + 25; i < CITY_SIZE/2; i += 50) {
                const points = [];
                for (let z = -CITY_SIZE/2; z <= CITY_SIZE/2; z += 2) {
                    points.push(new THREE.Vector3(i, 0.15, z));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            }
        }

        // 5. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¨Ø§Ù†ÙŠ ÙˆØ§Ù‚Ø¹ÙŠØ©
        function createRealisticBuildings() {
            const buildingTypes = [
                { colors: [0xa0a0a0, 0x888888], windows: true },
                { colors: [0x6a8ea0, 0x5a7e90], windows: true },
                { colors: [0xc0a080, 0xb09070], windows: false },
                { colors: [0x90a0b0, 0x8090a0], windows: true }
            ];

            for (let i = 0; i < MAX_BUILDINGS; i++) {
                const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const width = THREE.MathUtils.randFloat(8, 20);
                const depth = THREE.MathUtils.randFloat(8, 20);
                const height = THREE.MathUtils.randFloat(15, 40);

                // ØªØ¬Ù†Ø¨ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±Ù‚
                let pos_x, pos_z;
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 100) {
                    pos_x = THREE.MathUtils.randFloat(-CITY_SIZE/2 + 40, CITY_SIZE/2 - 40);
                    pos_z = THREE.MathUtils.randFloat(-CITY_SIZE/2 + 40, CITY_SIZE/2 - 40);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø¨Ù†Ù‰ Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±ÙŠÙ‚
                    const onRoad = Math.abs(pos_x % 50) < 20 || Math.abs(pos_z % 50) < 20;
                    if (!onRoad) {
                        validPosition = true;
                    }
                    attempts++;
                }

                if (!validPosition) continue;

                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¨Ù†Ù‰ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: type.colors[0],
                    roughness: 0.6,
                    metalness: 0.1
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(pos_x, height/2, pos_z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Ø¥Ø¶Ø§ÙØ© Ù†ÙˆØ§ÙØ° Ù„Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©
                if (type.windows && height > 20) {
                    createBuildingWindows(building, width, height, depth);
                }

                // Ø¥Ø¶Ø§ÙØ© Ø³Ù‚Ù
                const roofGeometry = new THREE.CylinderGeometry(width/1.5, width/2, 3, 8);
                const roof = new THREE.Mesh(roofGeometry, new THREE.MeshStandardMaterial({
                    color: 0x404040,
                    roughness: 0.8
                }));
                roof.position.set(pos_x, height + 1.5, pos_z);
                roof.castShadow = true;
                scene.add(roof);

                // Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ Ù„Ù„Ù…Ø¨Ù†Ù‰
                const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
                const body = new CANNON.Body({ 
                    mass: 0,
                    material: new CANNON.Material({
                        friction: 0.6,
                        restitution: 0.1
                    })
                });
                body.addShape(shape);
                body.position.set(pos_x, height/2, pos_z);
                world.addBody(body);
                physicsBodies.push(body);
            }
        }

        // 6. Ø¥Ø¶Ø§ÙØ© Ù†ÙˆØ§ÙØ° Ù„Ù„Ù…Ø¨Ø§Ù†ÙŠ
        function createBuildingWindows(building, width, height, depth) {
            const windowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffaa,
                transparent: true,
                opacity: 0.8
            });
            const windowSpacing = 4;
            
            for (let h = 5; h < height - 5; h += windowSpacing) {
                for (let w = -width/2 + 1; w < width/2 - 1; w += 3) {
                    const windowGeometry = new THREE.PlaneGeometry(1.5, 2);
                    const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                    const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
                    
                    window1.position.set(w, h, depth/2 + 0.1);
                    window2.position.set(w, h, -depth/2 - 0.1);
                    
                    window1.rotation.y = 0;
                    window2.rotation.y = Math.PI;
                    
                    building.add(window1);
                    building.add(window2);
                }
            }
        }

        // 7. Ø¥Ø¶Ø§ÙØ© Ù†Ø¨Ø§ØªØ§Øª
        function createVegetation() {
            for (let i = 0; i < 50; i++) {
                const treeHeight = THREE.MathUtils.randFloat(3, 8);
                let pos_x, pos_z;
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 50) {
                    pos_x = THREE.MathUtils.randFloat(-CITY_SIZE/2 + 10, CITY_SIZE/2 - 10);
                    pos_z = THREE.MathUtils.randFloat(-CITY_SIZE/2 + 10, CITY_SIZE/2 - 10);
                    
                    const onRoad = Math.abs(pos_x % 50) < 15 || Math.abs(pos_z % 50) < 15;
                    if (!onRoad) {
                        validPosition = true;
                    }
                    attempts++;
                }

                if (!validPosition) continue;
                
                // Ø¬Ø°Ø¹ Ø§Ù„Ø´Ø¬Ø±Ø©
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, treeHeight, 8);
                const trunk = new THREE.Mesh(trunkGeometry, new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9
                }));
                trunk.position.set(pos_x, treeHeight/2, pos_z);
                trunk.castShadow = true;
                scene.add(trunk);
                
                // Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø´Ø¬Ø±Ø©
                const leavesGeometry = new THREE.SphereGeometry(2, 8, 6);
                const leaves = new THREE.Mesh(leavesGeometry, new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    roughness: 0.8
                }));
                leaves.position.set(pos_x, treeHeight + 1, pos_z);
                leaves.castShadow = true;
                scene.add(leaves);

                // Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ Ù„Ù„Ø´Ø¬Ø±Ø©
                const treeShape = new CANNON.Cylinder(0.3, 0.4, treeHeight, 8);
                const treeBody = new CANNON.Body({ 
                    mass: 0,
                    material: new CANNON.Material({
                        friction: 0.5,
                        restitution: 0.2
                    })
                });
                treeBody.addShape(treeShape);
                treeBody.position.set(pos_x, treeHeight/2, pos_z);
                world.addBody(treeBody);
                physicsBodies.push(treeBody);
            }
        }

        // 8. Ø¥Ø¶Ø§ÙØ© Ø³ÙŠØ§Ø±Ø§Øª
        function createVehicles() {
            for (let i = 0; i < 15; i++) {
                const carType = Math.random() > 0.5 ? 'car' : 'truck';
                const length = carType === 'car' ? 4 : 6;
                const height = carType === 'car' ? 1.5 : 2.5;
                const width = carType === 'car' ? 2 : 2.5;
                
                const geometry = new THREE.BoxGeometry(length, height, width);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    roughness: 0.4,
                    metalness: 0.6
                });
                
                const car = new THREE.Mesh(geometry, material);
                
                // ÙˆØ¶Ø¹ Ø§Ù„Ø³ÙŠØ§Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø±ÙŠÙ‚
                const roadPosition = Math.floor(Math.random() * 8) * 50 - CITY_SIZE/2 + 25;
                const onRoad = Math.random() > 0.5;
                
                if (onRoad) {
                    car.position.set(roadPosition, height/2, THREE.MathUtils.randFloat(-CITY_SIZE/2 + 30, CITY_SIZE/2 - 30));
                } else {
                    car.position.set(THREE.MathUtils.randFloat(-CITY_SIZE/2 + 30, CITY_SIZE/2 - 30), height/2, roadPosition);
                }
                
                car.castShadow = true;
                scene.add(car);

                // Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ Ù„Ù„Ø³ÙŠØ§Ø±Ø©
                const carShape = new CANNON.Box(new CANNON.Vec3(length/2, height/2, width/2));
                const carBody = new CANNON.Body({ 
                    mass: 0,
                    material: new CANNON.Material({
                        friction: 0.4,
                        restitution: 0.3
                    })
                });
                carBody.addShape(carShape);
                carBody.position.copy(car.position);
                world.addBody(carBody);
                physicsBodies.push(carBody);
            }
        }

        // 9. Ø¥Ø¹Ø¯Ø§Ø¯ Ø¥Ø¶Ø§Ø¡Ø© ÙˆØ§Ù‚Ø¹ÙŠØ©
        function setupRealisticLighting() {
            // Ø¶ÙˆØ¡ Ø§Ù„Ù†Ù‡Ø§Ø± (Ø§Ù„Ø´Ù…Ø³)
            const sunLight = new THREE.DirectionalLight(0xfff4e6, 2.5);
            sunLight.position.set(200, 300, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -CITY_SIZE/2;
            sunLight.shadow.camera.right = CITY_SIZE/2;
            sunLight.shadow.camera.top = CITY_SIZE/2;
            sunLight.shadow.camera.bottom = -CITY_SIZE/2;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // Ø¶ÙˆØ¡ Ø§Ù„Ø³Ù…Ø§Ø¡
            const hemiLight = new THREE.HemisphereLight(0x87a6d6, 0x3c3c3c, 0.6);
            scene.add(hemiLight);

            // Ø£Ø¶ÙˆØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠØ©
            for (let i = -CITY_SIZE/2 + 25; i <= CITY_SIZE/2 - 25; i += 50) {
                const streetLight = new THREE.PointLight(0xfff4b3, 1, 50);
                streetLight.position.set(i, 8, 0);
                streetLight.castShadow = true;
                scene.add(streetLight);
                
                const lampGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const lamp = new THREE.Mesh(lampGeometry, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                lamp.position.set(i, 8, 0);
                scene.add(lamp);
            }
        }

        // 10. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¹ Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„ØªØµØ§Ø¯Ù…
        function createPlayer() {
            const playerHeight = 4;
            const playerRadius = 1;
            const playerShape = new CANNON.Sphere(playerRadius);
            
            playerBody = new CANNON.Body({
                mass: 10, // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ÙƒØªÙ„Ø© Ù„ØªØ«Ø¨ÙŠØª Ø£ÙØ¶Ù„
                position: new CANNON.Vec3(0, playerHeight + 5, 0), // Ø±ÙØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø£Ø¹Ù„Ù‰
                shape: playerShape,
                linearDamping: 0.95, // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ®Ù…ÙŠØ¯
                angularDamping: 0.98,
                fixedRotation: true, // Ù…Ù†Ø¹ Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ØºÙŠØ± Ø§Ù„Ù…Ø±ØºÙˆØ¨
                material: new CANNON.Material({ 
                    friction: 0.2,
                    restitution: 0.3
                })
            });
            
            world.addBody(playerBody);

            // Ø¬Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø±Ø¦ÙŠ
            const playerGeometry = new THREE.SphereGeometry(playerRadius, 32, 32);
            const playerMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                roughness: 0.3,
                metalness: 0.5,
                emissive: 0x003322,
                emissiveIntensity: 0.2
            });
            
            playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.castShadow = true;
            playerMesh.receiveShadow = true;
            scene.add(playerMesh);

            // Ù†Ø¸Ø§Ù… Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªØµØ§Ø¯Ù… Ø§Ù„Ù…Ø­Ø³Ù†
            let lastGroundContactTime = 0;
            
            playerBody.addEventListener('collide', (event) => {
                const contact = event.contact;
                collisionCount++;
                updateCollisionDebug();
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø£Ø±Ø¶ Ø£Ùˆ Ø£ÙŠ Ø¬Ø³Ù… Ø«Ø§Ø¨Øª
                const otherBody = event.body === playerBody ? event.target : event.body;
                
                if (otherBody.mass === 0) { // Ø¬Ø³Ù… Ø«Ø§Ø¨Øª (Ø£Ø±Ø¶ØŒ Ø¬Ø¯Ø§Ø±ØŒ Ù…Ø¨Ù†Ù‰)
                    const contactNormal = contact.ni;
                    
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„ (Ø§Ù„Ø£Ø±Ø¶)
                    if (contactNormal.y > 0.3) {
                        canJump = true;
                        jumpsRemaining = MAX_JUMPS;
                        energy = Math.min(100, energy + 25);
                        updateEnergyBar();
                        lastGroundContactTime = Date.now();
                        
                        // ØªØµØ­ÙŠØ­ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ù„Ù…Ù†Ø¹ Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚
                        const depth = contact.ri.length();
                        if (depth > 0.1) {
                            const correction = contactNormal.scale(depth * 0.5);
                            playerBody.position.vadd(correction, playerBody.position);
                        }
                    }
                }
            });

            // Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¯Ø§Ø¦Ù…Ø© Ù„Ù„ØªØµØ§Ø¯Ù…
            setInterval(() => {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ØªØ­Øª Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
                if (playerBody.position.y < -10) {
                    console.log("Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø³Ù‚Ø· ØªØ­Øª Ø§Ù„Ø£Ø±Ø¶ØŒ Ø¥Ø¹Ø§Ø¯ØªÙ‡...");
                    playerBody.position.set(0, 20, 0);
                    playerBody.velocity.set(0, 0, 0);
                    showMessage("ğŸ”„ ØªÙ… Ø¥Ø¹Ø§Ø¯ØªÙƒ Ø¥Ù„Ù‰ Ø§Ù„Ø³Ø·Ø­");
                }
                
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø§ØªØµØ§Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø±Ø¶ Ù„Ù…Ø¯Ø© Ø·ÙˆÙŠÙ„Ø©
                const timeSinceLastContact = Date.now() - lastGroundContactTime;
                if (timeSinceLastContact > 5000 && playerBody.position.y > 5) {
                    // Ø¥Ø¶Ø§ÙØ© Ù‚ÙˆØ© Ø¬Ø§Ø°Ø¨ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ©
                    playerBody.applyForce(new CANNON.Vec3(0, -50, 0), playerBody.position);
                }
            }, 1000);
        }

        // 11. Ù†Ø¸Ø§Ù… Ù‚ÙØ² Ù…ØªØ¹Ø¯Ø¯ Ù…Ø¹ Ø·Ø§Ù‚Ø©
        function jump() {
            const currentTime = Date.now();
            const timeSinceLastJump = currentTime - lastJumpTime;
            
            // ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø·Ø§Ù‚Ø© ÙƒØ§ÙÙŠØ©
            if (energy < 20) {
                showMessage("âš¡ Ù†ÙØ°Øª Ø§Ù„Ø·Ø§Ù‚Ø©! Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹");
                return;
            }

            // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ù‚ÙØ²
            if (timeSinceLastJump < 300) return;
            
            // Ø§Ø­ØªØ³Ø§Ø¨ Ù‚ÙˆØ© Ø§Ù„Ù‚ÙØ²
            const jumpStrength = BASE_JUMP_VELOCITY * (energy / 100);
            
            playerBody.velocity.y = jumpStrength;
            canJump = false;
            jumpsRemaining--;
            energy = Math.max(0, energy - 30);
            lastJumpTime = currentTime;
            
            updateEnergyBar();
            
            if (jumpsRemaining > 0) {
                showMessage(`âš¡ Ù‚ÙØ²Ø© ${MAX_JUMPS - jumpsRemaining + 1}/${MAX_JUMPS}`);
            } else {
                showMessage("âš ï¸ ØªØ­ØªØ§Ø¬ Ù„Ù…Ø³ Ø§Ù„Ø£Ø±Ø¶ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚ÙØ²");
            }
        }

        // 12. ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø·Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„ÙˆÙ‚Øª
        function regenerateEnergy() {
            if (energy < 100) {
                energy = Math.min(100, energy + 0.8);
                updateEnergyBar();
            }
        }

        // 13. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ­ÙƒÙ…
        function setupControls() {
            const joystickArea = document.getElementById('joystick-area');
            const joystickThumb = document.getElementById('joystick-thumb');
            const jumpButton = document.getElementById('jump-button');
            const lookArea = document.getElementById('look-area');

            // ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¹ØµØ§
            const rect = joystickArea.getBoundingClientRect();
            joystickCenter.x = rect.left + JOYSTICK_RADIUS;
            joystickCenter.y = rect.top + JOYSTICK_RADIUS;

            // Ø²Ø± Ø§Ù„Ù‚ÙØ²
            jumpButton.addEventListener('click', jump);
            jumpButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                jump();
            }, { passive: false });

            // ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
            document.addEventListener('touchstart', (event) => {
                isMobile = true;
                document.getElementById('mobile-controls').style.display = 'block';

                for (let touch of event.changedTouches) {
                    if (touch.clientX < window.innerWidth / 2) {
                        activeTouchId = touch.identifier;
                        joystickCenter.x = touch.clientX;
                        joystickCenter.y = touch.clientY;
                        
                        joystickArea.style.left = `${touch.clientX - JOYSTICK_RADIUS}px`;
                        joystickArea.style.top = `${touch.clientY - JOYSTICK_RADIUS}px`;
                        
                        touch.target.lastX = touch.clientX;
                        touch.target.lastY = touch.clientY;
                    } else {
                        touch.target.lastX = touch.clientX;
                        touch.target.lastY = touch.clientY;
                    }
                }
            }, { passive: false });

            document.addEventListener('touchmove', (event) => {
                event.preventDefault();
                
                for (let touch of event.changedTouches) {
                    // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø±Ø¤ÙŠØ©
                    if (touch.clientX >= window.innerWidth / 2 || touch.identifier !== activeTouchId) {
                        if (touch.target.lastX !== undefined) {
                            controls.yaw -= (touch.clientX - touch.target.lastX) * 0.004;
                            controls.pitch -= (touch.clientY - touch.target.lastY) * 0.004;
                            controls.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.pitch));
                        }
                    }

                    // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹ØµØ§
                    if (touch.identifier === activeTouchId) {
                        const dx = touch.clientX - joystickCenter.x;
                        const dy = touch.clientY - joystickCenter.y;
                        const distance = Math.min(JOYSTICK_RADIUS, Math.sqrt(dx * dx + dy * dy));
                        const angle = Math.atan2(dy, dx);

                        joystickThumb.style.transform = 
                            `translate(calc(-50% + ${Math.cos(angle) * distance}px), calc(-50% + ${Math.sin(angle) * distance}px))`;

                        const threshold = 0.2;
                        const normalizedX = Math.cos(angle) * (distance / JOYSTICK_RADIUS);
                        const normalizedY = Math.sin(angle) * (distance / JOYSTICK_RADIUS);

                        moveForward = normalizedY < -threshold;
                        moveBackward = normalizedY > threshold;
                        moveLeft = normalizedX < -threshold;
                        moveRight = normalizedX > threshold;
                    }
                    
                    touch.target.lastX = touch.clientX;
                    touch.target.lastY = touch.clientY;
                }
            }, { passive: false });

            document.addEventListener('touchend', (event) => {
                for (let touch of event.changedTouches) {
                    if (touch.identifier === activeTouchId) {
                        joystickThumb.style.transform = 'translate(-50%, -50%)';
                        moveForward = moveBackward = moveLeft = moveRight = false;
                        activeTouchId = null;
                        
                        joystickArea.style.left = `25px`;
                        joystickArea.style.top = `${window.innerHeight - 25 - JOYSTICK_RADIUS * 2}px`;
                        joystickCenter.x = 25 + JOYSTICK_RADIUS;
                        joystickCenter.y = window.innerHeight - 25 - JOYSTICK_RADIUS;
                    }
                }
            });

            // ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø§ÙˆØ³
            const element = document.body;
            element.addEventListener('click', () => {
                if (!isMobile && !document.pointerLockElement) {
                    element.requestPointerLock();
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === element) {
                    controls.yaw -= event.movementX * 0.002;
                    controls.pitch -= event.movementY * 0.002;
                    controls.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.pitch));
                }
            });

            document.addEventListener('keydown', (event) => {
                isMobile = false;
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': jump(); break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === element) {
                    document.getElementById('overlay').style.display = 'none';
                } else if (!isMobile) {
                    document.getElementById('overlay').style.display = 'flex';
                }
            });
        }

        // 14. Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªØµØ§Ø¯Ù…
        const forwardVector = new THREE.Vector3();
        const rightVector = new THREE.Vector3();
        const tempForce = new CANNON.Vec3();
        const movementForce = 350; // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ©

        function updatePlayerMovement(delta) {
            if (!isAuthReady) return;

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ù…Ø±Ø¦ÙŠ
            playerMesh.position.copy(playerBody.position);
            playerMesh.quaternion.copy(playerBody.quaternion);

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª
            forwardVector.set(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), controls.yaw);
            rightVector.set(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), controls.yaw);

            let force = tempForce.set(0, 0, 0);

            if (moveForward) force.vadd(new CANNON.Vec3(forwardVector.x * movementForce, 0, forwardVector.z * movementForce), force);
            if (moveBackward) force.vsub(new CANNON.Vec3(forwardVector.x * movementForce, 0, forwardVector.z * movementForce), force);
            if (moveRight) force.vadd(new CANNON.Vec3(rightVector.x * movementForce, 0, rightVector.z * movementForce), force);
            if (moveLeft) force.vsub(new CANNON.Vec3(rightVector.x * movementForce, 0, rightVector.z * movementForce), force);

            playerBody.applyForce(force, playerBody.position);

            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù‚ØµÙˆÙ‰
            let currentVelocity = playerBody.velocity;
            let speed = Math.sqrt(currentVelocity.x * currentVelocity.x + currentVelocity.z * currentVelocity.z);

            if (speed > maxSpeed) {
                const scale = maxSpeed / speed;
                playerBody.velocity.x *= scale;
                playerBody.velocity.z *= scale;
            }

            // Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø³Ù‚ÙˆØ·
            if (playerBody.position.y < -50) {
                playerBody.position.set(0, 30, 0);
                playerBody.velocity.set(0, 0, 0);
                showMessage("ğŸ”„ Ø³Ù‚Ø·Øª! ØªÙ… Ø¥Ø¹Ø§Ø¯ØªÙƒ");
                energy = 100;
                updateEnergyBar();
            }

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera.position.set(
                playerBody.position.x,
                playerBody.position.y + 2,
                playerBody.position.z + 3
            );
            camera.rotation.order = 'YXZ';
            camera.rotation.y = controls.yaw;
            camera.rotation.x = controls.pitch;
        }

        // 15. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¹Ø¯Ùˆ
        function createEnemy() {
            const enemyRadius = 2;
            const enemyShape = new CANNON.Sphere(enemyRadius);
            
            enemyBody = new CANNON.Body({
                mass: 20,
                position: new CANNON.Vec3(50, 5, 50),
                shape: enemyShape,
                linearDamping: 0.9,
                angularDamping: 0.9,
                fixedRotation: true,
                material: new CANNON.Material({ 
                    friction: 0.3,
                    restitution: 0.5
                })
            });
            
            world.addBody(enemyBody);

            const geometry = new THREE.SphereGeometry(enemyRadius, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff3333,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x330000,
                emissiveIntensity: 0.3
            });
            
            enemyMesh = new THREE.Mesh(geometry, material);
            enemyMesh.castShadow = true;
            enemyMesh.receiveShadow = true;
            scene.add(enemyMesh);
        }

        // 16. Ø°ÙƒØ§Ø¡ Ø§Ù„Ø¹Ø¯Ùˆ
        function updateEnemyAI(delta) {
            if (!enemyBody) return;

            const playerPos = playerBody.position;
            const enemyPos = enemyBody.position;
            
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ©
            const dx = playerPos.x - enemyPos.x;
            const dz = playerPos.z - enemyPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‚Ø±ÙŠØ¨Ø§Ù‹ØŒ ÙŠØ·Ø§Ø±Ø¯
            if (distance < 100 && distance > 5) {
                const chaseSpeed = 7;
                enemyBody.velocity.x = (dx / distance) * chaseSpeed;
                enemyBody.velocity.z = (dz / distance) * chaseSpeed;
            } else if (distance <= 5) {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¬Ø¯Ø§Ù‹ØŒ ÙŠØªÙˆÙ‚Ù
                enemyBody.velocity.x = 0;
                enemyBody.velocity.z = 0;
            }

            enemyMesh.position.copy(enemyBody.position);
            enemyMesh.quaternion.copy(enemyBody.quaternion);
        }

        // 17. Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡
        function animate(time) {
            requestAnimationFrame(animate);

            if (lastTime === undefined) {
                lastTime = time;
                return;
            }
            
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ Ø¨Ø®Ø·ÙˆØ§Øª Ø£ØµØºØ±
            world.step(1 / 60, delta, 10);

            // ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨
            updatePlayerMovement(delta);

            // ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø¯Ùˆ
            updateEnemyAI(delta);

            // ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø·Ø§Ù‚Ø©
            regenerateEnergy();

            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª
            animateVehicles(time);

            // Ø§Ù„Ø¹Ø±Ø¶
            renderer.render(scene, camera);
        }

        // 18. ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª
        function animateVehicles(time) {
            const cars = scene.children.filter(child => 
                child.type === 'Mesh' && child.geometry.type === 'BoxGeometry' && child.material.color
            );
            
            cars.forEach((car, index) => {
                const speed = 0.03;
                
                if (Math.abs(car.position.x % 50) < 10) {
                    car.position.z += speed;
                    if (car.position.z > CITY_SIZE/2 - 30) car.position.z = -CITY_SIZE/2 + 30;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø³Ù… Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ
                    const carBody = physicsBodies.find(b => 
                        b.position && 
                        Math.abs(b.position.x - car.position.x) < 1 &&
                        Math.abs(b.position.z - car.position.z) < 1
                    );
                    if (carBody) {
                        carBody.position.z = car.position.z;
                    }
                } else {
                    car.position.x += speed;
                    if (car.position.x > CITY_SIZE/2 - 30) car.position.x = -CITY_SIZE/2 + 30;
                    
                    const carBody = physicsBodies.find(b => 
                        b.position && 
                        Math.abs(b.position.x - car.position.x) < 1 &&
                        Math.abs(b.position.z - car.position.z) < 1
                    );
                    if (carBody) {
                        carBody.position.x = car.position.x;
                    }
                }
            });
        }

        // 19. Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            if (isMobile) {
                const joystickArea = document.getElementById('joystick-area');
                joystickArea.style.top = `${window.innerHeight - 25 - JOYSTICK_RADIUS * 2}px`;
                joystickCenter.x = 25 + JOYSTICK_RADIUS;
                joystickCenter.y = window.innerHeight - 25 - JOYSTICK_RADIUS;
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        document.getElementById('startButton').addEventListener('click', () => {
            init();
            animate();
            document.getElementById('overlay').style.display = 'none';
            showMessage("âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ÙƒÙ„Ø© Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©!");
        });

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£ÙˆÙ„ÙŠ
        window.addEventListener('load', () => {
            isMobile = window.innerWidth <= 768;
            if (isMobile) {
                const joystickArea = document.getElementById('joystick-area');
                joystickArea.style.top = `${window.innerHeight - 25 - JOYSTICK_RADIUS * 2}px`;
                document.getElementById('mobile-controls').style.display = 'block';
            }
            onWindowResize();
        });

        window.addEventListener('orientationchange', () => {
            isMobile = window.innerWidth <= 768;
            onWindowResize();
        });
    </script>
</body>
</html>
