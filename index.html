<!doctype html>
<html lang="ar" dir="rtl">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ù…Ù‡Ù…Ø© Ø§Ù„Ø¨Ø·Ù„ Ø§Ù„Ø£Ø³Ø·ÙˆØ±ÙŠ</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Tajawal', 'Cairo', Arial, sans-serif;
      background: #000000;
    }

    html, body {
      height: 100%;
      position: fixed;
      width: 100%;
      overflow: hidden;
    }

    .game-wrapper {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      overflow: hidden;
    }

    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      touch-action: none;
    }

    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 50;
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    .crosshair::before {
      width: 20px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair::after {
      width: 2px;
      height: 20px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .story-cinematic {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      padding: 30px;
      animation: fadeIn 1s ease-in;
    }

    .story-cinematic.hidden {
      display: none;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .cinematic-content {
      max-width: 800px;
      text-align: center;
    }

    .chapter-title {
      font-size: 56px;
      font-weight: bold;
      color: #ff6b6b;
      margin-bottom: 30px;
      text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
      animation: glow 2s ease-in-out infinite;
    }

    @keyframes glow {
      0%, 100% { text-shadow: 0 0 20px rgba(255, 107, 107, 0.8); }
      50% { text-shadow: 0 0 40px rgba(255, 107, 107, 1); }
    }

    .story-dialogue {
      font-size: 22px;
      color: #e0e0e0;
      line-height: 1.8;
      margin-bottom: 20px;
      opacity: 0;
      animation: slideUp 0.8s ease-out forwards;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .story-dialogue:nth-child(2) { animation-delay: 0.3s; }
    .story-dialogue:nth-child(3) { animation-delay: 0.6s; }
    .story-dialogue:nth-child(4) { animation-delay: 0.9s; }

    .continue-btn {
      margin-top: 30px;
      padding: 15px 50px;
      font-size: 24px;
      font-weight: bold;
      color: #ffffff;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: 3px solid #ffffff;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      animation: pulse 2s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(102, 126, 234, 0.6);
    }

    .continue-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 40px rgba(102, 126, 234, 0.9);
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .hud {
      position: absolute;
      top: 20px;
      right: 20px;
      left: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      z-index: 100;
      pointer-events: none;
    }

    .hud-panel {
      background: linear-gradient(145deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 40, 0.8));
      backdrop-filter: blur(15px);
      padding: 15px 25px;
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.6);
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
    }

    .game-title-hud {
      font-size: 20px;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 8px;
      text-shadow: 0 0 10px rgba(102, 126, 234, 0.8);
    }

    .hud-item {
      font-size: 16px;
      color: #ffffff;
      margin: 5px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .health-bar {
      width: 150px;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ff8787);
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
    }

    .ammo-display {
      font-size: 28px;
      font-weight: bold;
      color: #ffd93d;
      text-shadow: 0 0 10px rgba(255, 217, 61, 0.8);
    }

    .mission-objective {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(145deg, rgba(255, 107, 107, 0.9), rgba(255, 135, 135, 0.9));
      backdrop-filter: blur(10px);
      padding: 15px 30px;
      border-radius: 15px;
      border: 3px solid rgba(255, 255, 255, 0.5);
      color: #ffffff;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      z-index: 100;
      pointer-events: none;
      box-shadow: 0 4px 20px rgba(255, 107, 107, 0.6);
      animation: slideDown 0.5s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translate(-50%, -30px);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }

    .controls {
      position: absolute;
      bottom: 30px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 0 30px;
      z-index: 100;
      pointer-events: none;
    }

    .control-group {
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }

    .joystick-container {
      width: 140px;
      height: 140px;
      background: radial-gradient(circle, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3));
      border-radius: 50%;
      border: 3px solid rgba(102, 126, 234, 0.6);
      position: relative;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    .joystick-stick {
      width: 60px;
      height: 60px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.6), rgba(200, 200, 255, 0.6));
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 3px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      transition: all 0.1s ease;
    }

    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .action-btn {
      width: 75px;
      height: 75px;
      border-radius: 50%;
      background: linear-gradient(145deg, rgba(255, 107, 107, 0.7), rgba(245, 87, 108, 0.7));
      backdrop-filter: blur(10px);
      border: 3px solid rgba(255, 255, 255, 0.7);
      box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: #ffffff;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      font-weight: bold;
      transition: all 0.1s ease;
    }

    .action-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 15px rgba(255, 107, 107, 0.7);
    }

    .jump-btn {
      background: linear-gradient(145deg, rgba(102, 126, 234, 0.7), rgba(118, 75, 162, 0.7));
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
    }

    .instructions {
      position: absolute;
      bottom: 190px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(145deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 40, 0.8));
      backdrop-filter: blur(10px);
      padding: 12px 25px;
      border-radius: 12px;
      border: 2px solid rgba(102, 126, 234, 0.5);
      color: #ffffff;
      font-size: 14px;
      text-align: center;
      z-index: 100;
      pointer-events: none;
      white-space: nowrap;
    }

    @media (max-width: 768px) {
      .chapter-title {
        font-size: 36px;
      }

      .story-dialogue {
        font-size: 16px;
      }

      .continue-btn {
        font-size: 18px;
        padding: 12px 35px;
      }

      .hud-panel {
        padding: 10px 15px;
      }

      .game-title-hud {
        font-size: 16px;
      }

      .hud-item {
        font-size: 14px;
      }

      .health-bar {
        width: 100px;
        height: 16px;
      }

      .mission-objective {
        font-size: 14px;
        padding: 10px 20px;
        top: 100px;
      }

      .joystick-container {
        width: 120px;
        height: 120px;
      }

      .joystick-stick {
        width: 50px;
        height: 50px;
      }

      .action-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }

      .instructions {
        font-size: 12px;
        padding: 10px 20px;
        bottom: 170px;
      }
    }

    @media (orientation: landscape) and (max-height: 500px) {
      .hud-panel {
        padding: 8px 12px;
      }

      .controls {
        bottom: 20px;
      }

      .mission-objective {
        top: 80px;
        font-size: 14px;
      }
    }

    .enemy-indicator {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff6b6b;
      border-radius: 50%;
      border: 2px solid #ffffff;
      pointer-events: none;
      z-index: 90;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .damage-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.3));
      pointer-events: none;
      opacity: 0;
      z-index: 80;
      transition: opacity 0.2s ease;
    }

    .damage-overlay.active {
      opacity: 1;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="game-wrapper">
   <div id="gameCanvas"></div>
   <div class="crosshair"></div>
   <div class="damage-overlay" id="damageOverlay"></div>
   <div class="story-cinematic" id="storyCinematic">
    <div class="cinematic-content" id="cinematicContent"><!-- Story content will be dynamically inserted -->
    </div>
   </div>
   <div class="hud">
    <div class="hud-panel">
     <div class="game-title-hud" id="gameTitle">
      Ù…Ù‡Ù…Ø© Ø§Ù„Ø¨Ø·Ù„ Ø§Ù„Ø£Ø³Ø·ÙˆØ±ÙŠ
     </div>
     <div class="hud-item">
      Ø§Ù„ØµØ­Ø©: 
      <div class="health-bar">
       <div class="health-fill" id="healthFill" style="width: 100%;"></div>
      </div>
     </div>
     <div class="hud-item">
      Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="score">0</span>
     </div>
    </div>
    <div class="hud-panel">
     <div class="hud-item"><span>ğŸ”«</span> <span class="ammo-display" id="ammo">30</span>
     </div>
     <div class="hud-item">
      Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡: <span id="enemyCount">0</span>
     </div>
     <div class="hud-item">
      Ø§Ù„Ù…Ø±Ø­Ù„Ø©: <span id="chapter">1</span>
     </div>
    </div>
   </div>
   <div class="mission-objective" id="missionObjective">
    Ø§Ù„Ù…Ù‡Ù…Ø©: ØªØ®Ù„Øµ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©!
   </div>
   <div class="instructions">
    Ø§Ø³Ø­Ø¨ Ø§Ù„Ø´Ø§Ø´Ø© Ù„Ù„Ù†Ø¸Ø± â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¹ØµØ§ Ù„Ù„Ø­Ø±ÙƒØ© â€¢ Ù…Ø³Ø§ÙØ© Ù„Ù„Ù‚ÙØ² â€¢ Ø§Ù„Ù†Ù‚Ø± Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
   </div>
   <div class="controls">
    <div class="control-group">
     <div class="action-buttons">
      <div class="action-btn" id="shootBtn">
       ğŸ”«
      </div>
      <div class="action-btn jump-btn" id="jumpBtn">
       â¬†
      </div>
     </div>
    </div>
    <div class="control-group">
     <div class="joystick-container" id="joystickContainer">
      <div class="joystick-stick" id="joystickStick"></div>
     </div>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "Ù…Ù‡Ù…Ø© Ø§Ù„Ø¨Ø·Ù„ Ø§Ù„Ø£Ø³Ø·ÙˆØ±ÙŠ",
      primary_color: "#667eea",
      secondary_color: "#764ba2",
      accent_color: "#ff6b6b",
      ui_color: "#ffd93d",
      text_color: "#ffffff"
    };

    let config = {};

    async function onConfigChange(newConfig) {
      config = newConfig;
      
      const gameTitle = document.getElementById('gameTitle');
      if (gameTitle) gameTitle.textContent = config.game_title || defaultConfig.game_title;

      const primaryColor = config.primary_color || defaultConfig.primary_color;
      const accentColor = config.accent_color || defaultConfig.accent_color;
      const textColor = config.text_color || defaultConfig.text_color;

      document.querySelectorAll('.game-title-hud').forEach(el => {
        el.style.color = primaryColor;
      });

      document.querySelectorAll('.hud-item').forEach(el => {
        el.style.color = textColor;
      });
    }

    function mapToCapabilities(config) {
      return {
        recolorables: [
          {
            get: () => config.primary_color || defaultConfig.primary_color,
            set: (value) => {
              config.primary_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ primary_color: value });
              }
            }
          },
          {
            get: () => config.accent_color || defaultConfig.accent_color,
            set: (value) => {
              config.accent_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ accent_color: value });
              }
            }
          },
          {
            get: () => config.text_color || defaultConfig.text_color,
            set: (value) => {
              config.text_color = value;
              if (window.elementSdk) {
                window.elementSdk.setConfig({ text_color: value });
              }
            }
          }
        ],
        borderables: [],
        fontEditable: undefined,
        fontSizeable: undefined
      };
    }

    function mapToEditPanelValues(config) {
      return new Map([
        ["game_title", config.game_title || defaultConfig.game_title]
      ]);
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }

    // Story chapters
    const storyChapters = [
      {
        title: "âš”ï¸ Ø§Ù„ÙØµÙ„ Ø§Ù„Ø£ÙˆÙ„: Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©",
        dialogues: [
          "Ø£Ù†Øª Ø¬Ù†Ø¯ÙŠ Ø§Ù„Ù†Ø®Ø¨Ø© Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ø°ÙŠ Ø¨Ù‚ÙŠ Ø¹Ù„Ù‰ Ù‚ÙŠØ¯ Ø§Ù„Ø­ÙŠØ§Ø©...",
          "Ù‚Ø§Ø¹Ø¯ØªÙƒ ØªØ¹Ø±Ø¶Øª Ù„Ù‡Ø¬ÙˆÙ… Ù…ÙØ§Ø¬Ø¦ Ù…Ù† Ù‚ÙˆØ§Øª Ù…Ø¹Ø§Ø¯ÙŠØ© ØºØ§Ù…Ø¶Ø©!",
          "Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø¢Ù† Ø£Ù† ØªÙ‚Ø§ØªÙ„ Ø¨ÙƒÙ„ Ù…Ø§ Ù„Ø¯ÙŠÙƒ Ù…Ù† Ù‚ÙˆØ©...",
          "Ù…Ù‡Ù…ØªÙƒ: Ø§Ù„Ù‚Ø¶Ø§Ø¡ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ ÙˆØ§Ù„Ø¨Ù‚Ø§Ø¡ Ø¹Ù„Ù‰ Ù‚ÙŠØ¯ Ø§Ù„Ø­ÙŠØ§Ø©!"
        ],
        objective: "Ø§Ù„Ù…Ù‡Ù…Ø©: ØªØ®Ù„Øµ Ù…Ù† 10 Ø£Ø¹Ø¯Ø§Ø¡ ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰!",
        enemyCount: 10
      },
      {
        title: "ğŸ”¥ Ø§Ù„ÙØµÙ„ Ø§Ù„Ø«Ø§Ù†ÙŠ: Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¶Ø§Ø¯",
        dialogues: [
          "Ø¹Ù…Ù„ Ø±Ø§Ø¦Ø¹ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø¨Ø·Ù„! Ù„ÙƒÙ† Ø§Ù„Ù…Ø¹Ø±ÙƒØ© Ù„Ù… ØªÙ†ØªÙ‡ Ø¨Ø¹Ø¯...",
          "ØªÙ„Ù‚ÙŠÙ†Ø§ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ù…ÙˆØ¬Ø© Ø«Ø§Ù†ÙŠØ© Ù…Ù† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡!",
          "Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø© Ø§Ù„Ø¹Ø¯Ùˆ Ø£ÙƒØ«Ø± ØªÙ†Ø¸ÙŠÙ…Ø§Ù‹ ÙˆØ£ÙƒØ«Ø± Ø®Ø·ÙˆØ±Ø©...",
          "Ø§Ø³ØªØ¹Ø¯ Ù„Ù„Ù…ÙˆØ¬Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©! Ù„Ø§ ØªØ¯Ø¹Ù‡Ù… ÙŠÙ‚ØªØ±Ø¨ÙˆÙ† Ù…Ù† Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©!"
        ],
        objective: "Ø§Ù„Ù…Ù‡Ù…Ø©: ØµØ¯ Ù‡Ø¬ÙˆÙ… 15 Ø¹Ø¯Ùˆ Ù…Ù† Ø§Ù„Ù…ÙˆØ¬Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©!",
        enemyCount: 15
      },
      {
        title: "ğŸ’€ Ø§Ù„ÙØµÙ„ Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ù…ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©",
        dialogues: [
          "Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ù…Ø¹Ø±ÙƒØ© Ø§Ù„Ø­Ø§Ø³Ù…Ø© Ø£ÙŠÙ‡Ø§ Ø§Ù„Ù…Ø­Ø§Ø±Ø¨!",
          "Ù‚Ø§Ø¦Ø¯ Ø§Ù„Ù‚ÙˆØ§Øª Ø§Ù„Ù…Ø¹Ø§Ø¯ÙŠØ© ÙŠÙ‚ÙˆØ¯ Ø¨Ù†ÙØ³Ù‡ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø£Ø®ÙŠØ±...",
          "Ø¥Ù†Ù‡Ù… ÙŠØ£ØªÙˆÙ† Ø¨ÙƒØ§Ù…Ù„ Ù‚ÙˆØªÙ‡Ù… Ù„ØªØ¯Ù…ÙŠØ± ÙƒÙ„ Ø´ÙŠØ¡!",
          "Ù‡Ø°Ù‡ ÙØ±ØµØªÙƒ Ø§Ù„Ø£Ø®ÙŠØ±Ø©... Ø§Ù†ØªØµØ± Ø£Ùˆ Ø§Ø®Ø³Ø± ÙƒÙ„ Ø´ÙŠØ¡!"
        ],
        objective: "Ø§Ù„Ù…Ù‡Ù…Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: Ø§Ù‡Ø²Ù… 20 Ø¹Ø¯Ùˆ ÙˆØ§ÙƒÙ…Ù„ Ø§Ù„Ù…Ù‡Ù…Ø©!",
        enemyCount: 20
      }
    ];

    let currentChapter = 0;
    let gameStarted = false;

    // Three.js Setup
    let scene, camera, renderer;
    let player, enemies = [], projectiles = [];
    let keys = {};
    let mouseMovement = { x: 0, y: 0 };
    let playerRotation = { x: 0, y: 0 };
    let playerVelocity = new THREE.Vector3(0, 0, 0);
    const gravity = -0.8;
    const jumpPower = 10;
    const moveSpeed = 0.1;

    let playerHealth = 100;
    let score = 0;
    let ammo = 30;
    let enemiesKilled = 0;
    let totalEnemiesInChapter = 10;

    // Joystick variables
    let joystickActive = false;
    let joystickDirection = { x: 0, y: 0 };

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);

      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x1a1a2e);
      document.getElementById('gameCanvas').appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      directionalLight.position.set(20, 30, 20);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Dramatic lighting
      const redLight = new THREE.PointLight(0xff0000, 1, 30);
      redLight.position.set(-15, 5, -15);
      scene.add(redLight);

      const blueLight = new THREE.PointLight(0x0000ff, 1, 30);
      blueLight.position.set(15, 5, -15);
      scene.add(blueLight);

      // Ground with realistic textures
      const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.95,
        metalness: 0.05
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      
      // Add terrain variation
      const positions = groundGeometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const height = Math.sin(x * 0.15) * Math.cos(y * 0.15) * 0.5 + 
                      Math.sin(x * 0.3) * 0.2 + 
                      Math.random() * 0.1;
        positions.setZ(i, height);
      }
      groundGeometry.computeVertexNormals();
      scene.add(ground);

      // Add roads/paths
      createRoads();
      
      // Add street details
      createStreetLights();
      createVehicles();
      createDebris();

      // Create environment
      createBuildings();
      createCover();
      createProps();

      // Player reference (invisible, camera is the player)
      player = {
        position: new THREE.Vector3(0, 2, 0),
        rotation: new THREE.Vector2(0, 0),
        velocity: new THREE.Vector3(0, 0, 0),
        onGround: true
      };

      window.addEventListener('resize', onWindowResize);
      setupControls();
      
      showStoryChapter(0);
    }

    function showStoryChapter(chapterIndex) {
      const cinematic = document.getElementById('storyCinematic');
      const content = document.getElementById('cinematicContent');
      const chapter = storyChapters[chapterIndex];

      content.innerHTML = `
        <div class="chapter-title">${chapter.title}</div>
        ${chapter.dialogues.map(d => `<div class="story-dialogue">${d}</div>`).join('')}
        <button class="continue-btn" onclick="startChapter()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ù‡Ù…Ø© âš¡</button>
      `;

      cinematic.classList.remove('hidden');
    }

    window.startChapter = function() {
      document.getElementById('storyCinematic').classList.add('hidden');
      const chapter = storyChapters[currentChapter];
      document.getElementById('missionObjective').textContent = chapter.objective;
      document.getElementById('chapter').textContent = currentChapter + 1;
      
      totalEnemiesInChapter = chapter.enemyCount;
      enemiesKilled = 0;
      
      spawnEnemies(chapter.enemyCount);
      
      if (!gameStarted) {
        gameStarted = true;
        animate();
      }
    };

    function createBuildings() {
      // Create varied building types
      const buildingTypes = [
        { color: 0x2c3e50, windows: true },
        { color: 0x34495e, windows: true },
        { color: 0x7f8c8d, windows: false },
        { color: 0x95a5a6, windows: true }
      ];

      for (let i = 0; i < 12; i++) {
        const width = 6 + Math.random() * 8;
        const height = 10 + Math.random() * 20;
        const depth = 6 + Math.random() * 8;
        const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
        
        const buildingGroup = new THREE.Group();
        
        // Main building structure
        const buildingMaterial = new THREE.MeshStandardMaterial({
          color: type.color,
          roughness: 0.85,
          metalness: 0.15
        });
        
        const building = new THREE.Mesh(
          new THREE.BoxGeometry(width, height, depth),
          buildingMaterial
        );
        building.castShadow = true;
        building.receiveShadow = true;
        buildingGroup.add(building);
        
        // Add windows
        if (type.windows) {
          const windowMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() > 0.3 ? 0x4a5f7f : 0xffeb3b,
            emissive: Math.random() > 0.3 ? 0x1a2f4f : 0xffeb3b,
            emissiveIntensity: 0.6,
            roughness: 0.2,
            metalness: 0.8
          });
          
          const floors = Math.floor(height / 2.5);
          const windowsPerRow = Math.floor(width / 1.5);
          
          for (let f = 0; f < floors; f++) {
            for (let w = 0; w < windowsPerRow; w++) {
              const window1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.2, 0.1),
                windowMaterial
              );
              window1.position.set(
                -width/2 + (w + 0.5) * (width / windowsPerRow),
                -height/2 + (f + 0.5) * (height / floors),
                depth/2 + 0.05
              );
              buildingGroup.add(window1);
              
              const window2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.2, 0.1),
                windowMaterial.clone()
              );
              window2.position.set(
                -width/2 + (w + 0.5) * (width / windowsPerRow),
                -height/2 + (f + 0.5) * (height / floors),
                -depth/2 - 0.05
              );
              buildingGroup.add(window2);
            }
          }
        }
        
        // Add rooftop details
        if (Math.random() > 0.5) {
          const roofDetail = new THREE.Mesh(
            new THREE.BoxGeometry(width * 0.3, 1, depth * 0.3),
            new THREE.MeshStandardMaterial({ color: 0x555555 })
          );
          roofDetail.position.y = height/2 + 0.5;
          roofDetail.castShadow = true;
          buildingGroup.add(roofDetail);
        }
        
        const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 30 + Math.random() * 15;
        buildingGroup.position.x = Math.cos(angle) * radius;
        buildingGroup.position.z = Math.sin(angle) * radius;
        buildingGroup.position.y = height / 2;
        
        scene.add(buildingGroup);
      }
    }

    function createRoads() {
      const roadMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.9,
        metalness: 0.1
      });

      // Main roads
      const road1 = new THREE.Mesh(
        new THREE.PlaneGeometry(8, 100),
        roadMaterial
      );
      road1.rotation.x = -Math.PI / 2;
      road1.position.y = 0.02;
      road1.receiveShadow = true;
      scene.add(road1);

      const road2 = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 8),
        roadMaterial
      );
      road2.rotation.x = -Math.PI / 2;
      road2.position.y = 0.02;
      road2.receiveShadow = true;
      scene.add(road2);

      // Road markings
      const lineMaterial = new THREE.MeshStandardMaterial({
        color: 0xffff00,
        emissive: 0xffff00,
        emissiveIntensity: 0.3
      });

      for (let i = -50; i < 50; i += 4) {
        const line1 = new THREE.Mesh(
          new THREE.PlaneGeometry(0.2, 2),
          lineMaterial
        );
        line1.rotation.x = -Math.PI / 2;
        line1.position.set(0, 0.03, i);
        scene.add(line1);

        const line2 = new THREE.Mesh(
          new THREE.PlaneGeometry(2, 0.2),
          lineMaterial
        );
        line2.rotation.x = -Math.PI / 2;
        line2.position.set(i, 0.03, 0);
        scene.add(line2);
      }
    }

    function createStreetLights() {
      const poleMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.6,
        metalness: 0.7
      });

      const lightMaterial = new THREE.MeshStandardMaterial({
        color: 0xffa500,
        emissive: 0xffa500,
        emissiveIntensity: 1
      });

      for (let i = 0; i < 8; i++) {
        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 6, 8),
          poleMaterial
        );
        
        const angle = (i / 8) * Math.PI * 2;
        const radius = 20;
        pole.position.set(Math.cos(angle) * radius, 3, Math.sin(angle) * radius);
        pole.castShadow = true;
        scene.add(pole);

        const light = new THREE.Mesh(
          new THREE.SphereGeometry(0.3, 16, 16),
          lightMaterial
        );
        light.position.set(Math.cos(angle) * radius, 6, Math.sin(angle) * radius);
        scene.add(light);

        const pointLight = new THREE.PointLight(0xffa500, 0.5, 15);
        pointLight.position.copy(light.position);
        scene.add(pointLight);
      }
    }

    function createVehicles() {
      const carColors = [0xff0000, 0x0000ff, 0xffff00, 0x00ff00, 0x888888];

      for (let i = 0; i < 6; i++) {
        const carGroup = new THREE.Group();

        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: carColors[Math.floor(Math.random() * carColors.length)],
          roughness: 0.4,
          metalness: 0.6
        });

        const body = new THREE.Mesh(
          new THREE.BoxGeometry(2, 1, 4),
          bodyMaterial
        );
        body.position.y = 0.5;
        body.castShadow = true;
        carGroup.add(body);

        const cabin = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.8, 2),
          bodyMaterial
        );
        cabin.position.y = 1.4;
        cabin.castShadow = true;
        carGroup.add(cabin);

        const windowMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333,
          roughness: 0.1,
          metalness: 0.9
        });

        const windshield = new THREE.Mesh(
          new THREE.BoxGeometry(1.7, 0.6, 0.1),
          windowMaterial
        );
        windshield.position.set(0, 1.4, 1);
        carGroup.add(windshield);

        carGroup.position.x = (Math.random() - 0.5) * 35;
        carGroup.position.z = (Math.random() - 0.5) * 35;
        carGroup.position.y = 0;
        carGroup.rotation.y = Math.random() * Math.PI * 2;

        scene.add(carGroup);
      }
    }

    function createDebris() {
      const debrisMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.9
      });

      for (let i = 0; i < 20; i++) {
        const size = 0.3 + Math.random() * 0.7;
        const debris = new THREE.Mesh(
          new THREE.BoxGeometry(size, size * 0.5, size),
          debrisMaterial
        );
        
        debris.position.x = (Math.random() - 0.5) * 45;
        debris.position.z = (Math.random() - 0.5) * 45;
        debris.position.y = size * 0.25;
        debris.rotation.y = Math.random() * Math.PI;
        
        debris.castShadow = true;
        debris.receiveShadow = true;
        scene.add(debris);
      }
    }

    function createCover() {
      const coverTypes = [
        { color: 0x7f8c8d, type: 'wall' },
        { color: 0x8b4513, type: 'wood' },
        { color: 0x2c3e50, type: 'metal' }
      ];

      for (let i = 0; i < 20; i++) {
        const coverType = coverTypes[Math.floor(Math.random() * coverTypes.length)];
        const coverMaterial = new THREE.MeshStandardMaterial({
          color: coverType.color,
          roughness: coverType.type === 'metal' ? 0.5 : 0.8,
          metalness: coverType.type === 'metal' ? 0.7 : 0.2
        });

        const cover = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 1.8, 0.4),
          coverMaterial
        );
        
        cover.position.x = (Math.random() - 0.5) * 40;
        cover.position.z = (Math.random() - 0.5) * 40;
        cover.position.y = 0.9;
        cover.rotation.y = Math.random() * Math.PI * 2;
        
        cover.castShadow = true;
        cover.receiveShadow = true;
        scene.add(cover);
      }
    }

    function createProps() {
      // Crates
      const crateMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.9
      });

      for (let i = 0; i < 15; i++) {
        const size = 1 + Math.random() * 1;
        const crateGroup = new THREE.Group();
        
        const crate = new THREE.Mesh(
          new THREE.BoxGeometry(size, size, size),
          crateMaterial
        );
        crate.castShadow = true;
        crate.receiveShadow = true;
        crateGroup.add(crate);

        // Add crate details
        const stripMaterial = new THREE.MeshStandardMaterial({
          color: 0x654321,
          roughness: 0.8
        });
        
        const strip1 = new THREE.Mesh(
          new THREE.BoxGeometry(size + 0.02, 0.1, 0.1),
          stripMaterial
        );
        strip1.position.y = size * 0.3;
        strip1.position.z = size / 2 + 0.01;
        crateGroup.add(strip1);
        
        crateGroup.position.x = (Math.random() - 0.5) * 45;
        crateGroup.position.z = (Math.random() - 0.5) * 45;
        crateGroup.position.y = size / 2;
        crateGroup.rotation.y = Math.random() * Math.PI;
        
        scene.add(crateGroup);
      }

      // Metal barrels
      const barrelMaterial = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.6,
        metalness: 0.8
      });

      for (let i = 0; i < 10; i++) {
        const barrel = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16),
          barrelMaterial
        );
        
        barrel.position.x = (Math.random() - 0.5) * 40;
        barrel.position.z = (Math.random() - 0.5) * 40;
        barrel.position.y = 0.6;
        
        barrel.castShadow = true;
        barrel.receiveShadow = true;
        scene.add(barrel);
      }

      // Concrete barriers
      const barrierMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.9,
        metalness: 0.1
      });

      for (let i = 0; i < 8; i++) {
        const barrier = new THREE.Mesh(
          new THREE.BoxGeometry(3, 0.8, 0.5),
          barrierMaterial
        );
        
        barrier.position.x = (Math.random() - 0.5) * 35;
        barrier.position.z = (Math.random() - 0.5) * 35;
        barrier.position.y = 0.4;
        barrier.rotation.y = Math.random() * Math.PI;
        
        barrier.castShadow = true;
        barrier.receiveShadow = true;
        scene.add(barrier);
      }

      // Trash containers
      const trashMaterial = new THREE.MeshStandardMaterial({
        color: 0x2d5016,
        roughness: 0.7,
        metalness: 0.3
      });

      for (let i = 0; i < 6; i++) {
        const trash = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1.2, 0.8),
          trashMaterial
        );
        
        trash.position.x = (Math.random() - 0.5) * 38;
        trash.position.z = (Math.random() - 0.5) * 38;
        trash.position.y = 0.6;
        
        trash.castShadow = true;
        trash.receiveShadow = true;
        scene.add(trash);
      }
    }

    function spawnEnemies(count) {
      enemies.forEach(enemy => scene.remove(enemy.mesh));
      enemies = [];

      for (let i = 0; i < count; i++) {
        setTimeout(() => {
          createEnemy();
        }, i * 500);
      }

      updateEnemyCount();
    }

    function createEnemy() {
      const enemyGroup = new THREE.Group();
      
      const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.5,
        metalness: 0.5,
        emissive: 0x660000,
        emissiveIntensity: 0.3
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.6;
      body.castShadow = true;
      enemyGroup.add(body);

      const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xcc0000,
        roughness: 0.4,
        metalness: 0.6
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.5;
      head.castShadow = true;
      enemyGroup.add(head);

      const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xffff00,
        emissive: 0xffff00,
        emissiveIntensity: 1
      });
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.12, 1.55, 0.25);
      enemyGroup.add(leftEye);
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.12, 1.55, 0.25);
      enemyGroup.add(rightEye);

      const angle = Math.random() * Math.PI * 2;
      const distance = 20 + Math.random() * 15;
      enemyGroup.position.x = Math.cos(angle) * distance;
      enemyGroup.position.z = Math.sin(angle) * distance;
      enemyGroup.position.y = 0;

      scene.add(enemyGroup);

      enemies.push({
        mesh: enemyGroup,
        health: 100,
        speed: 0.03 + Math.random() * 0.02,
        attackCooldown: 0,
        alive: true
      });
    }

    function setupControls() {
      document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.code === 'Space') {
          e.preventDefault();
          handleJump();
        }
      });

      document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      let lastTouchX = 0;
      let lastTouchY = 0;
      let touchLookActive = false;

      document.addEventListener('mousemove', (e) => {
        if (gameStarted && !document.getElementById('storyCinematic').classList.contains('hidden')) return;
        
        mouseMovement.x = (e.movementX || 0) * 1.5;
        mouseMovement.y = (e.movementY || 0) * 1.5;
      });

      // Touch look controls for mobile
      renderer.domElement.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1 && !joystickActive) {
          touchLookActive = true;
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        }
      });

      renderer.domElement.addEventListener('touchmove', (e) => {
        if (touchLookActive && e.touches.length === 1) {
          e.preventDefault();
          const deltaX = e.touches[0].clientX - lastTouchX;
          const deltaY = e.touches[0].clientY - lastTouchY;
          
          mouseMovement.x = deltaX * 1.2;
          mouseMovement.y = deltaY * 1.2;
          
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        }
      });

      renderer.domElement.addEventListener('touchend', (e) => {
        if (e.touches.length === 0) {
          touchLookActive = false;
        }
      });

      document.addEventListener('click', () => {
        if (gameStarted && document.getElementById('storyCinematic').classList.contains('hidden')) {
          shoot();
        }
      });

      renderer.domElement.addEventListener('click', () => {
        renderer.domElement.requestPointerLock();
      });

      // Touch controls
      const joystickContainer = document.getElementById('joystickContainer');
      const joystickStick = document.getElementById('joystickStick');

      joystickContainer.addEventListener('touchstart', handleJoystickStart);
      joystickContainer.addEventListener('touchmove', handleJoystickMove);
      joystickContainer.addEventListener('touchend', handleJoystickEnd);

      document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleJump();
      });

      document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        shoot();
      });

      document.getElementById('jumpBtn').addEventListener('click', handleJump);
      document.getElementById('shootBtn').addEventListener('click', shoot);
    }

    function handleJoystickStart(e) {
      e.preventDefault();
      joystickActive = true;
    }

    function handleJoystickMove(e) {
      if (!joystickActive) return;
      e.preventDefault();

      const touch = e.touches[0];
      const rect = e.target.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      let deltaX = touch.clientX - centerX;
      let deltaY = touch.clientY - centerY;

      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const maxDistance = rect.width / 2 - 30;

      if (distance > maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
      }

      joystickDirection.x = deltaX / maxDistance;
      joystickDirection.y = deltaY / maxDistance;

      const stick = document.getElementById('joystickStick');
      stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
    }

    function handleJoystickEnd(e) {
      e.preventDefault();
      joystickActive = false;
      joystickDirection = { x: 0, y: 0 };
      
      const stick = document.getElementById('joystickStick');
      stick.style.transform = 'translate(-50%, -50%)';
    }

    function handleJump() {
      if (player.onGround) {
        player.velocity.y = jumpPower;
        player.onGround = false;
      }
    }

    function shoot() {
      if (ammo <= 0) return;

      ammo--;
      document.getElementById('ammo').textContent = ammo;

      const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const projectileMaterial = new THREE.MeshStandardMaterial({
        color: 0xffff00,
        emissive: 0xffff00,
        emissiveIntensity: 1
      });
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

      projectile.position.copy(camera.position);

      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);

      scene.add(projectile);

      projectiles.push({
        mesh: projectile,
        velocity: direction.multiplyScalar(1.5),
        life: 100
      });

      // Add ammo after some time
      setTimeout(() => {
        ammo = Math.min(30, ammo + 1);
        document.getElementById('ammo').textContent = ammo;
      }, 1000);
    }

    function updatePlayer() {
      // Mouse look
      playerRotation.y -= mouseMovement.x * 0.002;
      playerRotation.x -= mouseMovement.y * 0.002;
      playerRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, playerRotation.x));
      mouseMovement.x = 0;
      mouseMovement.y = 0;

      camera.rotation.order = 'YXZ';
      camera.rotation.y = playerRotation.y;
      camera.rotation.x = playerRotation.x;

      // Movement
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
      
      forward.y = 0;
      right.y = 0;
      forward.normalize();
      right.normalize();

      const moveVector = new THREE.Vector3(0, 0, 0);

      if (keys['w'] || keys['arrowup'] || joystickDirection.y < -0.3) {
        moveVector.add(forward.multiplyScalar(moveSpeed));
      }
      if (keys['s'] || keys['arrowdown'] || joystickDirection.y > 0.3) {
        moveVector.add(forward.multiplyScalar(-moveSpeed));
      }
      if (keys['a'] || keys['arrowleft'] || joystickDirection.x < -0.3) {
        moveVector.add(right.multiplyScalar(-moveSpeed));
      }
      if (keys['d'] || keys['arrowright'] || joystickDirection.x > 0.3) {
        moveVector.add(right.multiplyScalar(moveSpeed));
      }

      player.velocity.x = moveVector.x;
      player.velocity.z = moveVector.z;

      // Gravity
      player.velocity.y += gravity * 0.016;
      player.position.y += player.velocity.y * 0.016;

      if (player.position.y <= 2) {
        player.position.y = 2;
        player.velocity.y = 0;
        player.onGround = true;
      }

      player.position.x += player.velocity.x;
      player.position.z += player.velocity.z;

      // Boundaries
      player.position.x = Math.max(-45, Math.min(45, player.position.x));
      player.position.z = Math.max(-45, Math.min(45, player.position.z));

      camera.position.copy(player.position);

      // Update HUD
      document.getElementById('score').textContent = score;
    }

    function updateEnemies() {
      enemies.forEach((enemy, index) => {
        if (!enemy.alive) return;

        const direction = new THREE.Vector3()
          .subVectors(player.position, enemy.mesh.position)
          .normalize();

        enemy.mesh.position.add(direction.multiplyScalar(enemy.speed));
        enemy.mesh.lookAt(player.position);

        const distance = enemy.mesh.position.distanceTo(player.position);

        if (distance < 2) {
          enemy.attackCooldown--;
          if (enemy.attackCooldown <= 0) {
            playerHealth -= 5;
            enemy.attackCooldown = 60;
            
            const healthFill = document.getElementById('healthFill');
            healthFill.style.width = Math.max(0, playerHealth) + '%';
            
            const damageOverlay = document.getElementById('damageOverlay');
            damageOverlay.classList.add('active');
            setTimeout(() => damageOverlay.classList.remove('active'), 200);

            if (playerHealth <= 0) {
              gameOver();
            }
          }
        }

        // Update enemy indicator on screen
        updateEnemyIndicator(enemy, index);
      });
    }

    function updateEnemyIndicator(enemy, index) {
      let indicator = document.getElementById(`enemy-indicator-${index}`);
      
      if (!indicator && enemy.alive) {
        indicator = document.createElement('div');
        indicator.id = `enemy-indicator-${index}`;
        indicator.className = 'enemy-indicator';
        document.body.appendChild(indicator);
      }

      if (indicator && enemy.alive) {
        const vector = enemy.mesh.position.clone();
        vector.project(camera);

        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

        if (vector.z < 1) {
          indicator.style.left = x + 'px';
          indicator.style.top = y + 'px';
          indicator.style.display = 'block';
        } else {
          indicator.style.display = 'none';
        }
      }
    }

    function updateProjectiles() {
      projectiles.forEach((projectile, pIndex) => {
        projectile.mesh.position.add(projectile.velocity);
        projectile.life--;

        if (projectile.life <= 0) {
          scene.remove(projectile.mesh);
          projectiles.splice(pIndex, 1);
          return;
        }

        enemies.forEach((enemy, eIndex) => {
          if (!enemy.alive) return;

          const distance = projectile.mesh.position.distanceTo(enemy.mesh.position);
          if (distance < 1) {
            enemy.health -= 50;

            if (enemy.health <= 0) {
              enemy.alive = false;
              scene.remove(enemy.mesh);
              
              const indicator = document.getElementById(`enemy-indicator-${eIndex}`);
              if (indicator) indicator.remove();
              
              score += 100;
              enemiesKilled++;
              updateEnemyCount();

              if (enemiesKilled >= totalEnemiesInChapter) {
                completeChapter();
              }
            }

            scene.remove(projectile.mesh);
            projectiles.splice(pIndex, 1);
          }
        });
      });
    }

    function updateEnemyCount() {
      const aliveEnemies = enemies.filter(e => e.alive).length;
      document.getElementById('enemyCount').textContent = aliveEnemies;
    }

    function completeChapter() {
      currentChapter++;
      
      if (currentChapter < storyChapters.length) {
        setTimeout(() => {
          showStoryChapter(currentChapter);
        }, 1000);
      } else {
        victoryScreen();
      }
    }

    function victoryScreen() {
      const cinematic = document.getElementById('storyCinematic');
      const content = document.getElementById('cinematicContent');

      content.innerHTML = `
        <div class="chapter-title">ğŸ† Ø§Ù„Ù†ØµØ± Ø§Ù„Ù…Ø¨ÙŠÙ†!</div>
        <div class="story-dialogue">Ù„Ù‚Ø¯ Ø£Ù†Ø¬Ø²Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­ Ø£ÙŠÙ‡Ø§ Ø§Ù„Ø¨Ø·Ù„!</div>
        <div class="story-dialogue">Ø£Ù†Ù‚Ø°Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© ÙˆÙ‡Ø²Ù…Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡!</div>
        <div class="story-dialogue">Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${score}</div>
        <button class="continue-btn" onclick="location.reload()">Ø§Ù„Ø¹Ø¨ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ ğŸ”„</button>
      `;

      cinematic.classList.remove('hidden');
    }

    function gameOver() {
      const cinematic = document.getElementById('storyCinematic');
      const content = document.getElementById('cinematicContent');

      content.innerHTML = `
        <div class="chapter-title">ğŸ’€ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</div>
        <div class="story-dialogue">Ù„Ù‚Ø¯ Ø³Ù‚Ø·Øª ÙÙŠ Ø§Ù„Ù…Ø¹Ø±ÙƒØ©...</div>
        <div class="story-dialogue">Ù„ÙƒÙ† Ø§Ù„Ø¨Ø·Ù„ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù„Ø§ ÙŠØ³ØªØ³Ù„Ù… Ø£Ø¨Ø¯Ø§Ù‹!</div>
        <div class="story-dialogue">Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}</div>
        <button class="continue-btn" onclick="location.reload()">Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ ğŸ”„</button>
      `;

      cinematic.classList.remove('hidden');
      gameStarted = false;
    }

    function animate() {
      if (!gameStarted) return;

      requestAnimationFrame(animate);

      updatePlayer();
      updateEnemies();
      updateProjectiles();

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9aa42a9ce14bd0e2',t:'MTc2NTExMjAxMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>