<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Desert Drifter - ÙˆØ§Ù‚Ø¹ÙŠØ© Ø§Ù„Ø­Ø±ÙƒØ© ÙˆØ§Ù„Ø±Ù…Ù„</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e6c288; font-family: sans-serif; touch-action: none; user-select: none; }
        
        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„ØªØ­ÙƒÙ… */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #score-board { position: absolute; top: 20px; right: 20px; color: #3d2e1e; font-size: 20px; font-weight: bold; text-shadow: 0 1px 5px rgba(255,255,255,0.5); }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(61, 46, 30, 0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff; z-index: 20;
        }
        button {
            background: #d4b483; color: #3d2e1e; border: 2px solid #fff; padding: 15px 40px;
            font-size: 22px; cursor: pointer; border-radius: 50px; font-weight: bold; margin-top: 20px;
        }

        .controls { pointer-events: auto; position: absolute; bottom: 40px; display: none; }
        #joystick-zone { left: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); }
        #joystick-knob { width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #jump-btn { 
            right: 40px; bottom: 60px; width: 80px; height: 80px; 
            background: rgba(255,255,255,0.2); border: 3px solid rgba(255,255,255,0.5); 
            border-radius: 50%; color: white; display: flex; justify-content: center; align-items: center;
            font-size: 14px; font-weight: bold; pointer-events: auto;
        }
        #jump-btn:active { background: rgba(255,255,255,0.5); transform: scale(0.95); }

        /* Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ¯ÙˆÙŠØ± (Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠ) */
        #rotate-msg {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #fff; z-index: 100; justify-content: center; align-items: center; text-align: center;
        }
        @media screen and (orientation: portrait) {
            #rotate-msg { display: flex; }
        }
    </style>
</head>
<body>

    <div id="rotate-msg"><h1>ÙŠØ±Ø¬Ù‰ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ù‡Ø§ØªÙ Ù„Ù„Ø¹Ø¨ ğŸ”„</h1></div>

    <div id="ui-layer">
        <div id="score-board">Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø£Ø«Ø±ÙŠØ©: <span id="score">0</span> / 5</div>
        <div id="joystick-zone" class="controls"><div id="joystick-knob"></div></div>
        <div id="jump-btn" class="controls">Ù‚ÙØ²</div>
    </div>

    <div id="start-screen">
        <h1>Desert Drifter</h1>
        <p>Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø£Ø«Ø±ÙŠØ© Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© Ø¨ÙŠÙ† Ø§Ù„ÙƒØ«Ø¨Ø§Ù† Ø§Ù„Ø±Ù…Ù„ÙŠØ©</p>
        <button id="start-btn">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… ---
        let scene, camera, renderer, clock;
        let terrainMesh;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        
        // ÙÙŠØ²ÙŠØ§Ø¡ Ø§Ù„Ø­Ø±ÙƒØ©
        let velocity = new THREE.Vector3();
        const speed = 25.0; // Ø³Ø±Ø¹Ø© ÙˆØ§Ù‚Ø¹ÙŠØ©
        const gravity = 30.0; // Ù‚ÙˆØ© Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ©
        const jumpHeight = 12.0;
        
        let score = 0;
        let targets = [];
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
        const simplex = new SimplexNoise();
        const playerHeight = 1.6; // Ø·ÙˆÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ø«Ø§Ø¨Øª)

        init();
        animate();

        function init() {
            clock = new THREE.Clock();

            // 1. Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ø³Ù…Ø§Ø¡
            scene = new THREE.Scene();
            const skyColor = 0xE6D4B8; // Ù„ÙˆÙ† Ø³Ù…Ø§Ø¡ ØµØ­Ø±Ø§ÙˆÙŠ Ù…ØºØ¨Ø±
            scene.background = new THREE.Color(skyColor);
            scene.fog = new THREE.FogExp2(skyColor, 0.015);

            // 2. Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 5, 0);

            // 3. Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© (Ø¥Ø¶Ø§Ø¡Ø© Ø´Ù…Ø³ Ù‚ÙˆÙŠØ©)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffdfba, 1.2);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 4. Ø¨Ù†Ø§Ø¡ Ø§Ù„ØªØ¶Ø§Ø±ÙŠØ³ (Ø§Ù„ÙƒØ«Ø¨Ø§Ù† Ø§Ù„Ø±Ù…Ù„ÙŠØ©)
            createTerrain();

            // 5. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
            createDecorations();

            // 6. Ø§Ù„Ø±ÙŠÙ†Ø¯Ø±
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 7. Ø§Ù„ØªØ­ÙƒÙ…
            setupControls();
            
            window.addEventListener('resize', onWindowResize);
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(300, 300, 100, 100);
            geometry.rotateX(-Math.PI / 2);

            // ØªØ¹Ø¯ÙŠÙ„ Ø§Ø±ØªÙØ§Ø¹Ø§Øª Ø§Ù„Ù†Ù‚Ø§Ø· Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ«Ø¨Ø§Ù†
            const pos = geometry.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                let y = simplex.noise2D(x * 0.02, z * 0.02) * 4; 
                y += simplex.noise2D(x * 0.1, z * 0.1) * 0.5;
                pos.setY(i, y);
            }
            geometry.computeVertexNormals();

            // Ù…Ø§Ø¯Ø© Ø§Ù„Ø±Ù…Ù„ (Ø£ÙƒØ«Ø± ÙˆØ§Ù‚Ø¹ÙŠØ©: Ø®Ø´ÙˆÙ†Ø© Ø¹Ø§Ù„ÙŠØ© ÙˆØ§Ù†Ø¹ÙƒØ§Ø³ Ù‚Ù„ÙŠÙ„)
            const material = new THREE.MeshStandardMaterial({
                color: 0xd4b483, // Ù„ÙˆÙ† Ø§Ù„Ø±Ù…Ù„ Ø§Ù„Ø¯Ø§ÙØ¦
                roughness: 1.0, // Ø®Ø´ÙˆÙ†Ø© Ø¹Ø§Ù„ÙŠØ© (Ù„ÙŠØ³Øª Ù„Ø§Ù…Ø¹Ø©)
                metalness: 0.0,
                // Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³Ø·Ø­ (Flat Shading) Ù„Ø¬Ø¹Ù„ Ø§Ù„ØªÙ…ÙˆØ¬Ø§Øª Ø£ÙƒØ«Ø± ÙˆØ¶ÙˆØ­Ù‹Ø§
                flatShading: false 
            });

            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);
        }

        function createDecorations() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ù‡Ø¯Ø§Ù (Ø¨Ù„ÙˆØ±Ø§Øª Ø²Ø±Ù‚Ø§Ø¡)
            const targetGeo = new THREE.DodecahedronGeometry(0.8);
            const targetMat = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x0044ff, shininess: 100 });

            for(let i=0; i<5; i++) {
                const mesh = new THREE.Mesh(targetGeo, targetMat);
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                const y = getTerrainHeight(x, z) + 1.5;
                
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                scene.add(mesh);
                targets.push(mesh);
                
                const pLight = new THREE.PointLight(0x00ffff, 1, 10);
                mesh.add(pLight);
            }
            
            // Ø¥Ø¶Ø§ÙØ© ØµØ®ÙˆØ± (Dodecahedrons)
            const rockGeo = new THREE.DodecahedronGeometry(1, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9 });
            
            for(let i=0; i<30; i++) {
                const rock = new THREE.Mesh(rockGeo, rockMat);
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                const s = Math.random() * 2 + 0.5;
                rock.scale.set(s, s*0.7, s);
                rock.position.set(x, getTerrainHeight(x, z), z);
                rock.receiveShadow = true;
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        function getTerrainHeight(x, z) {
            let y = simplex.noise2D(x * 0.02, z * 0.02) * 4; 
            y += simplex.noise2D(x * 0.1, z * 0.1) * 0.5;
            return y;
        }

        function setupControls() {
            const startBtn = document.getElementById('start-btn');
            const startScreen = document.getElementById('start-screen');
            const jumpBtn = document.getElementById('jump-btn');

            startBtn.addEventListener('click', () => {
                startScreen.style.display = 'none';
                if (!isMobile) {
                    document.body.requestPointerLock();
                } else {
                    document.querySelectorAll('.controls').forEach(e => e.style.display = 'block');
                    document.getElementById('jump-btn').style.display = 'flex';
                    initTouchControls();
                }
            });

            // --- ØªØ­ÙƒÙ… Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ---
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if(canJump) velocity.y = jumpHeight; canJump = false; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }
            });

            // --- ØªØ­ÙƒÙ… Ø§Ù„Ù‚ÙØ² (Ù…ÙˆØ¨Ø§ÙŠÙ„) ---
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (canJump) {
                    velocity.y = jumpHeight;
                    canJump = false;
                }
            }, {passive: false});
        }

        function initTouchControls() {
            const joyZone = document.getElementById('joystick-zone');
            const joyKnob = document.getElementById('joystick-knob');
            let startX, startY;
            
            // Ø§Ù„Ø¬ÙˆÙŠØ³ØªÙŠÙƒ (Ø§Ù„Ø­Ø±ÙƒØ©)
            joyZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            }, {passive: false});

            joyZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;
                const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 35);
                const angle = Math.atan2(dy, dx);
                
                const mx = Math.cos(angle) * dist;
                const my = Math.sin(angle) * dist;
                
                joyKnob.style.transform = `translate(calc(-50% + ${mx}px), calc(-50% + ${my}px))`;
                
                moveForward = my < -10;
                moveBackward = my > 10;
                moveLeft = mx < -10;
                moveRight = mx > 10;
            }, {passive: false});

            joyZone.addEventListener('touchend', () => {
                joyKnob.style.transform = `translate(-50%, -50%)`;
                moveForward = moveBackward = moveLeft = moveRight = false;
            });

            // Ø¯ÙˆØ±Ø§Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (Ø§Ù„Ù†Ø¸Ø±)
            let lastX = 0;
            document.addEventListener('touchstart', (e) => {
                if (!e.target.closest('.controls')) {
                    lastX = e.touches[0].clientX;
                }
            });
            document.addEventListener('touchmove', (e) => {
                if (!e.target.closest('.controls')) {
                    const deltaX = e.touches[0].clientX - lastX;
                    camera.rotation.y -= deltaX * 0.005;
                    lastX = e.touches[0].clientX;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© (Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ) ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1); 
            
            // 1. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ©
            velocity.y -= gravity * delta;

            // 2. Ø­Ø³Ø§Ø¨ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ© (Ø¬Ø¯ÙŠØ¯: ÙŠØªÙ… Ø­Ø³Ø§Ø¨Ù‡Ø§ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§)
            
            // Ù†Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù†Ø§Ù‚Ù„ (Vector) ÙŠÙ…Ø«Ù„ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Ø¥Ø²Ø§Ù„Ø© Ù…ÙƒÙˆÙ† Ø§Ù„Ù€ Y Ù…Ù† Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù„Ù…Ù†Ø¹ Ø§Ù„Ø·ÙŠØ±Ø§Ù† Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø´ÙŠ)
            cameraDirection.y = 0;
            cameraDirection.normalize(); 
            
            const sideways = new THREE.Vector3();
            sideways.crossVectors(camera.up, cameraDirection).normalize();

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø±ÙƒØ© (ØªØµÙÙŠØ± Ø§Ù„Ø³Ø±Ø¹Ø© Ø«Ù… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¨Ù†Ø§Ø¡)
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            if (moveForward || moveBackward) {
                const forwardFactor = (moveForward ? 1 : 0) - (moveBackward ? 1 : 0);
                velocity.x += cameraDirection.x * forwardFactor * speed * delta * 50;
                velocity.z += cameraDirection.z * forwardFactor * speed * delta * 50;
            }

            if (moveLeft || moveRight) {
                const sidewaysFactor = (moveRight ? 1 : 0) - (moveLeft ? 1 : 0);
                velocity.x += sideways.x * sidewaysFactor * speed * delta * 50;
                velocity.z += sideways.z * sidewaysFactor * speed * delta * 50;
            }

            // 3. ØªØ­Ø±ÙŠÙƒ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (Ø§Ù„Ù„Ø§Ø¹Ø¨)
            camera.position.x += velocity.x * delta;
            camera.position.z += velocity.z * delta;
            camera.position.y += velocity.y * delta;

            // 4. Ø§Ù„ØªØµØ§Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø£Ø±Ø¶ (Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡)
            const terrainH = getTerrainHeight(camera.position.x, camera.position.z);
            if (camera.position.y < terrainH + playerHeight) {
                velocity.y = 0;
                camera.position.y = terrainH + playerHeight;
                canJump = true;
            }

            // 5. ØªØ¯ÙˆÙŠØ± ÙˆØ¬Ù…Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
            targets.forEach((t, i) => {
                t.rotation.y += delta;
                t.position.y = getTerrainHeight(t.position.x, t.position.z) + 1.5 + Math.sin(clock.getElapsedTime() * 2 + i) * 0.2;
                
                if(camera.position.distanceTo(t.position) < 2) {
                    scene.remove(t);
                    targets.splice(i, 1);
                    score++;
                    document.getElementById('score').innerText = score;
                    if(score === 5) alert("ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒ! Ù„Ù‚Ø¯ ÙˆØ¬Ø¯Øª ÙƒÙ„ Ø§Ù„ÙƒÙ†ÙˆØ²!");
                }
            });
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
